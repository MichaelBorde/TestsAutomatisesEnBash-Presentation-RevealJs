<!doctype html>
<html lang="fr">

  <head>
    <meta charset="utf-8">

    <title>Tests automatisés en Bash</title>

    <meta name="description" content="Tests automatisés en Bash">
    <meta name="author" content="Michael">

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="reveal.js/css/reveal.min.css">
    <link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">

    <!-- Thème utilisé par highlight.js -->
    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

    <link rel="stylesheet" href="css/redefinitions.css">

    <!-- Mettre 'print-pdf' dans la requête pour activer la css d'impression PDF -->
    <script>
      if (window.location.search.match(/print-pdf/gi)) {
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'reveal.js/css/print/pdf.css';
        document.getElementsByTagName('head')[0].appendChild(link);
      }
    </script>

    <!--[if lt IE 9]>
    <script src="reveal.js/lib/js/html5shiv.js"></script><![endif]-->
  </head>

  <body>
    <div class="reveal">

      <div class="slides">
        <section>
          <h1>#!</h1>

          <h3>Tests automatisés en Bash</h3>

          <p>
            <small><a href="http://michaelborde.fr">Michael Borde</a> / <a href="http://twitter.com/michael_borde">@michael_borde</a>
              / <a href="http://arpinum.fr">Arpinum</a>
            </small>
          </p>
          <img width="10%" height="10%" src="images/logo-arpinum.png" alt="Arpinum">
          <aside class="notes">
            Bonjour à tous et merci d'être présent. Je suis Michael Borde, développeur passionné chez
            Arpinum. Je vais vous parler de mon hobby du moment : les tests automatisés en Bash.
          </aside>
        </section>

        <section>
          <h2>Le contexte</h2>

          <aside class="notes">
            Je travaille sur un plateau de développement et je suis en charge, avec mon équipe, d'améliorer
            le quotidien de tous les fabricants.
          </aside>
        </section>

        <section>
          <h2>Ces 28 derniers jours</h2>

          <div>
            <img width="10%" height="10%" src="images/28-jours-plus-tard.jpg" alt="28 jours plus tard">
          </div>
          <ul>
            <li>109 entrepôts</li>
            <li>1812 commits</li>
            <li>48 auteurs actifs</li>
          </ul>
          <aside class="notes">
            Nous sommes suffisamment nombreux pour que ce travail soit aussi intéressant que compliqué.
          </aside>
        </section>

        <section>
          <h2>Retournons quelques temps en arrière...</h2>
          <aside class="notes">
            Mais prenons la DeLorean et retournons quelques temps en arrière.
          </aside>
        </section>

        <section>
          <p>Et si nous automatisions les opérations répétitives et sensibles ?</p>

          <aside class="notes">
            Tout a commencé lorsque nous avons décidé d'automatiser certaines opérations répétitives et
            sensibles du quotidien.
          </aside>
        </section>

        <section>
          <h2>Un outil simple : Bash</h2>
          <img width="60%" height="60%" src="images/cle-a-molette.jpg" alt="Clé à molette">
          <aside class="notes">
            En faisant le tour de nos postes de développements et des différents serveurs, le plus simple
            était d'utiliser Bash.
          </aside>
        </section>

        <section>
          <h2>3 fois rien finalement</h2>
          <ul>
            <li>Cloner des entrepôts</li>
            <li>Mettre à jour des sources</li>
          </ul>
          <aside class="notes">
            3 fois rien finalement : cloner ou mettre à jour en masse des entrepôts Git.
          </aside>
        </section>

        <section>
          <h2>Mais avec un peu d'imagination</h2>
          <ul>
            <li>Créer/supprimer des branches</li>
            <li>Créer/supprimer des jobs Jenkins</li>
            <li>Lister les entrepôts à fusionner</li>
            <li>Réaliser la livraison des projets</li>
            <li>etc.</li>
          </ul>
          <p>18 vaillants scripts</p>
          <aside class="notes">
            Mais bien vite nous avons imaginé de nombreux cas d'utilisations : créer des branches ou jobs
            Jenkins en masse, livrer les projets de manière automatique, etc. Au final nous avons un peu
            moins de 20 scripts.
          </aside>
        </section>

        <section>
          <h2>Et il y en a pour tout le monde</h2>
          <img width="60%" height="60%" src="images/equipe-developpement.jpg" alt="Equipe développement">

          <p>Développeurs, administrateurs, livreurs, etc.</p>
          <aside class="notes">
            Ils concernent un peu tout le monde : développeurs, administrateurs, etc.
          </aside>
        </section>

        <section>
          <h2>Dans des contextes multiples</h2>
          <img width="20%" height="20%" src="images/logo-cygwin.png" alt="Logo Cygwin"> <img width="20%"
                                                                                             height="20%"
                                                                                             src="images/logo-jenkins.png"
                                                                                             alt="Logo Jenkins">
          <img width="20%" height="20%" src="images/logo-linux.png" alt="Logo Linux">

          <p class="fragment">avec un mode de tests manuels, mais chut!</p>

          <aside class="notes">
            Ils sont utilisables sur un poste de développement Windows, un serveur Linux ou via un job
            Jenkins. Il y a même un mode de tests manuels pour vérifier qu'on ne va pas déclencher l'enfer
            en situation réelle.
          </aside>
        </section>

        <section>
          <h2>Les conseils de Google</h2>
          <blockquote>
            If you are writing a script that is more than 100 lines long, you should probably be writing it
            in Python instead.
          </blockquote>

          <aside class="notes">
            Nous appliquons les préconisations Bash des équipes Google, sauf une peut-être : "si vous
            écrivez un script de plus de 100 lignes, vous devriez surement l'écrire en Python."
          </aside>
        </section>

        <section>
          <p>En Python !</p>
          <figure>
            <img width="60%" height="60%" src="images/dawson-triste.jpg" alt="Dawson triste">
            <figcaption>
              <small>© Toute la production de Dawson's Creek</small>
            </figcaption>
          </figure>
          <aside class="notes">
            En python ! Il est malheureux Dawson, il n'a pas envie de faire du Python, il veut sortir avec
            Katie Holmes comme tout le monde.
          </aside>
        </section>

        <section>
          <p>Eh oui, scripter en Bash c'est un peu...</p>
          <img width="20%" height="20%" src="images/dé.jpg" alt="Dé"/> <img width="20%" height="20%"
                                                                            src="images/stackoverflow.png"
                                                                            alt="Stackoverflow"> <img
                width="20%" height="20%" src="images/necronomicon.jpg" alt="Necronomicon">
          <aside class="notes">
            Mais c'est compréhensible. Quand je regarde des exemples de code sur le net je me dis que
            scripter en Bash c'est un peu de chance et beaucoup de Stackoverflow. Heureusement dans les
            situations désespérées il reste le Nécronomicon.
          </aside>
        </section>

        <section>
          <h2>Et pourtant 4796 lignes de Bash ! </h2>
          <aside class="notes">
            Et pourtant nous avons accumulé près de 5000 lignes de Bash.
          </aside>
        </section>

        <section>
          <img width="60%" height="60%" src="images/panneau-stop.jpg" alt="Panneau stop">

          <aside class="notes">
            Bash n'est pas le problème de fond.
          </aside>
        </section>

        <section>
          <h2>Il faut tacler la complexité</h2>

          <aside class="notes">
            Notre ennemi est la complexité que nous produisons nous même.
          </aside>
        </section>

        <section>
          <p>Et si Bash était un langage de programmation ?</p>

          <aside class="notes">
            Et si Bash n'était pas un langage de script mais un langage de programmation comme les autres ?
          </aside>
        </section>

        <section>
          <h2>Les outils habituels</h2>
          <img width="20%" height="20%" src="images/livre-tdd-by-example.jpeg" alt="TDD By Example">
          <img width="20%" height="20%" src="images/livre-xp-explained.jpg" alt="XP Explained">
          <img width="20%" height="20%" src="images/livre-clean-code.jpg" alt="Clean Code">
          <aside class="notes">
            Alors je dégainerais TDD, XP et Clean Code.
          </aside>
        </section>

        <section>
          <h2>Clean Code, concrètement ?</h2>
          <aside class="notes">
            Il est tout à fait possible, en Bash, de respecter le principe de responsabilité unique, d'avoir
            du code sans duplication et qui exprime l'intention.
          </aside>
        </section>

        <section>
          <h2>Un équivalent à JUnit ?</h2>
          <img width="30%" height="30%" src="images/junit.jpg" alt="JUnit">
          <aside class="notes">
            Par contre, existe t-il un équivalent à JUnit ?
          </aside>
        </section>

        <section>
          <p>Bof...</p>
          <aside class="notes">
            Bof... et je ne me satisfais pas d'un bof.
          </aside>
        </section>

        <section>
          <p>Je vais créer mon api de tests automatisés en Bash !</p>
          <img width="60%" height="60%" src="images/serious-cat.jpg" alt="Serious cat">
          <aside class="notes">
            Alors j'ai décidé de créer ma propre api de tests automatisés en Bash !
          </aside>
        </section>

        <section>
          <h2>Les objectifs de l'api</h2>
          <ul>
            <li>Favoriser TDD</li>
            <li>Ressembler à xUnit</li>
            <li>Compatible avec l'IC</li>
            <li>Respecter la notion de tests unitaires</li>
            <li>En français</li>
          </ul>
          <aside class="notes">
            L'objectif numéro 1 de l'API était de favoriser TDD. Mais je souhaitais aussi quelle ressemble à
            xUnit, soit compatible avec Jenkins et respecte la notion de tests unitaires. Si en plus elle
            pouvait être en français comme le reste de notre code, ça serait parfait.
          </aside>
        </section>

        <section>
          <h2>Make them <strong>first</strong></h2>
          <ul>
            <li><strong>F</strong>ast</li>
            <li><strong>I</strong>solated <span class="exclamation">!</span></li>
            <li><strong>R</strong>epeatable <span class="exclamation">!</span></li>
            <li><strong>S</strong>elf-verifying <span class="exclamation">!</span></li>
            <li><strong>T</strong>imely</li>
          </ul>
          <aside class="notes">
            En m'appuyant sur la définiton FIRST de test unitaire, je voulais me concentrer sur les 3 points
            du milieu : isolé, répétable, auto-vérifiant. Isolé, est une gageure par exemple. En Bash nous
            pouvons facilement modifier des variables globales, créer ou détruire des arborescences. J'ai eu
            mon quota de surprises désagréables.
          </aside>
        </section>

        <section>
          <h2>Et donc ?</h2>
          <aside class="notes">
            Et donc voici quelques exemples de l'API. Ils sont un peu édulcorés pour faciliter la
            compréhension.
          </aside>
        </section>

        <section>
          <h2>L'exécuteur de test</h2>
          <aside class="notes">
            Le grand stratégaire est l'exécuteur de test.
          </aside>
        </section>

        <section>
          <h2>Exécuter tous les fichiers de test</h2>
          <pre><code data-trim class="bash">
function executeur_executeLesFichiersDeTestDansLeRepertoire() {
  local repertoire=$1
  _initialiseLExecutionDesTests
  _executeTousFichiersDeTest "${repertoire}" "*Test.sh"
  _afficheLeResultatDesTests
  _retourneUnCodeEnFonctionDuResultatDesTests
}
          </code></pre>
          <aside class="notes">
            L'exécuteur exécute tous les fichiers de tests qui respectent un certain motif pour un
            répertoire donné. Il affiche le résultat global des tests et retourne un code en fonction de
            l'exécution.
          </aside>
        </section>

        <section>
          <h2>Exécuter un fichier de test</h2>
          <pre><code data-trim class="bash">
function _executeLeFichierDeTest() {
  local fichier=$1
  source "${fichier}"
  local fonctions=("$(_fonctionsPubliquesDansLeFichier "${fichier}")")
  _executeFonctionSiPresente "avantTousLesTests" "${fonctions[@]}"
  _executeTousLesTests "${fonctions[@]}"
  _executeFonctionSiPresente "apresTousLesTests" "${fonctions[@]}"
}
          </code></pre>
          <aside class="notes">
            Pour un fichier de test, il récupère les fonctions publiques qui par convention seront les
            fonctions de test. Il exécute tous les tests entre les setups et teardowns globaux si présents.
          </aside>
        </section>

        <section>
          <h2>Exécuter une fonction de test</h2>

          <pre><code data-trim class="bash">
function _executeLaFonctionAuMilieuDuSetupEtTeardown() {
  local fonction=$1
  shift 1
  _executeFonctionSiPresente "avantChaqueTest" "$@" \
  && ${fonction} \
  && _executeFonctionSiPresente "apresChaqueTest" "$@"
  _analyseLExecutionDuTest "${fonction}" $?
}
          </code></pre>
          <aside class="notes">
            Pour une fonction de test, il l'exécute entre le setup et teardown si présents et analyse le
            code retour.
          </aside>
        </section>

        <section>
          <h2>Quelques affirmations</h2>
          <aside class="notes">
            Une API de test automatisés ne serait rien sans ses affirmations.
          </aside>
        </section>

        <section>
          <h2>Affirmer l'égalité</h2>
          <pre><code data-trim class="bash">
function affirmation_affirmeEgalite() {
  local attendu=$1
  local obtenu=$2
  if [[ "${attendu}" != "${obtenu}" ]]; then
    _affirmationEnErreur "Obtenu : <${obtenu}>, attendu : <${attendu}>."
  fi
}
          </code></pre>
          <aside class="notes">
            Voici une simple affirmation pour l'égalité. C'est le plus simple qui fonctionne.
          </aside>
        </section>

        <section>
          <h2>Affirmer le succés</h2>
          <pre><code data-trim class="bash">
function affirmation_affirmeSucces() {
  ( $@ )
  if (( $? != 0 )); then
      _affirmationEnErreur "La commande a échoué au lieu de réussir."
  fi
}
          </code></pre>
          <aside class="notes">
            Une autre pour affirmer le succès d'une commande. C'est très utile puisque les fonctions Bash ne
            retournent que des codes d'erreur.
          </aside>
        </section>

        <section>
          <h2>Quelques exemples</h2>
          <aside class="notes">
            Quelques exemples de tests.
          </aside>
        </section>

        <section>
          <h2>Un test unitaire</h2>
          <pre><code data-trim class="bash">
function recupereBienLaVersionDunPom() {
  local pom="${_ressources}/pom_1.0.xml"

  local version=$(maven_recupereLaVersionDuPom "${pom}")

  affirmation_affirmeEgalite "1.0" "${version}"
}
          </code></pre>
          <aside class="notes">
            Etant donné un pom.xml en version 1.0, si je demande la version de ce pom, j'obtiens bien 1.0.
          </aside>
        </section>

        <section>
          <h2>Un test d'intégration</h2>
          <pre><code data-trim class="bash">
function ilEstPossibleDeChangerLaBrancheDUnEntrepot() {
  entrepot_cloneLaBrancheDeLEntrepot "integration" "module-a"

  source "${REPERTOIRE_SCRIPT}/checkout.sh" -p "mod*" "master"

  local branche="$(_recupereLaBrancheCouranteDeLEntrepot "module-a")"
  affirmation_affirmeEgalite "master" "${branche}"
}
          </code></pre>
          <aside class="notes">
            Un exemple plus ambitieux avec un test d'intégration. Je clone l'entrepôt module-a, je demande
            un changement vers la branche master de tous les entrepôts qui commencent par mod et j'affirme
            que module-a est sur la branche master.
          </aside>
        </section>

        <section>
          <figure>
            <img width="100%" height="100%" src="images/resultat-tests.png" alt="Résultat tests">
            <figcaption>
              Exemple de sortie console
            </figcaption>
          </figure>
          <aside class="notes">
            Et pour finir, un exemple de sortie console avec de belles couleurs et un résumé de l'exécution
            en bas.
          </aside>
        </section>

        <section>
          <h2>Reprenons les statistiques</h2>

          <p>Lignes de code Bash :</p>
          <ul>
            <li><strong>Total</strong> : 4796 (100%)</li>
            <li><strong>Production</strong> : 2797 (58%)</li>
            <li><strong>Tests</strong> : 1671 (35%)</li>
            <li><strong>API de tests</strong> : 328 (7%)</li>
          </ul>
          <aside class="notes">
            Quand on regarde la répartition des 5000 lignes de Bash, on s'aperçoit qu'il y a un tier de
            test. La couverture doit être moins bonne que sur d'autres projets mais pour des opérations
            proches du système, je trouve ça plutôt satisfaisant.
          </aside>
        </section>

        <section>
          <h2>Et pour le fun</h2>

          <p>Nombre de tests (temps) :</p>
          <ul>
            <li><strong>Tests unitaires</strong> : 91 (13 s)</li>
            <li><strong>Tests d'intégration</strong> : 109 (10 min)</li>
          </ul>
          <aside class="notes">Voici la répartition des TU/TI. Nous avons beaucoup trop de tests d'intégration
            à mon goût et ils sont longs. C'est symptomatique de la programmation système. L'inversion de
            contrôle y est assez complexe mais pas impossible. Quoiqu'il en soit, ces tests nous assurent
            une certaine sérénité.
          </aside>
        </section>

        <section>
          <h2>Fin</h2>

          <p>Pour les curieux :</p>

          <p><a href="http://github.com/arpinum/shebang_unit" title="shebang_unit">http://github.com/arpinum/shebang_unit</a>
          </p>

          <aside class="notes">Pour les curieux, j'ai partagé shebang_unit sur Github. C'est la petite soeur
            libre de droit de l'API que je viens de présenter. Ceci conclu mon intervention. Merci.
          </aside>
        </section>
      </div>
    </div>

    <script src="reveal.js/lib/js/head.min.js"></script>
    <script src="reveal.js/js/reveal.min.js"></script>

    <script>

      Reveal.initialize({
        controls: false,
        progress: true,
        history: true,
        center: true,
        mouseWheel: true,

        theme: Reveal.getQueryHash().theme || 'beige',
        transition: Reveal.getQueryHash().transition || 'none',

        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function () {
            return !document.body.classList;
          } },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function () {
            hljs.initHighlightingOnLoad();
          } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function () {
            return !!document.body.classList;
          } }
        ]
      });

      window.addEventListener("mousedown", handleClick, false);
      window.addEventListener("contextmenu", function (e) {
        e.preventDefault();
      }, false);

      function handleClick(e) {
        if (!e.target || e.target.tagName !== 'A') {
          e.preventDefault();
          if (e.button === 0) Reveal.next();
          if (e.button === 2) Reveal.prev();
        }
      }
    </script>

  </body>
</html>
