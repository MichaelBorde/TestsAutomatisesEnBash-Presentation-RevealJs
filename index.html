<!doctype html>
<html lang="fr">

    <head>
        <meta charset="utf-8">

        <title>Tests automatisés en Bash</title>

        <meta name="description" content="Tests automatisés en Bash">
        <meta name="author" content="Michael">

        <meta name="apple-mobile-web-app-capable" content="yes"/>
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <link rel="stylesheet" href="reveal.js/css/reveal.min.css">
        <link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">

        <!-- Thème utilisé par highlight.js -->
        <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

        <link rel="stylesheet" href="css/redefinitions.css">

        <!-- Mettre 'print-pdf' dans la requête pour activer la css d'impression PDF -->
        <script>
            if (window.location.search.match(/print-pdf/gi)) {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = 'reveal.js/css/print/pdf.css';
                document.getElementsByTagName('head')[0].appendChild(link);
            }
        </script>

        <!--[if lt IE 9]>
        <script src="reveal.js/lib/js/html5shiv.js"></script><![endif]-->
    </head>

    <body>
        <div class="reveal">

            <div class="slides">
                <section>
                    <img width="100%" height="100%" src="images/ouverture-agile-france.jpg"
                         alt="Ouverture Agile France"/>

                    <aside class="notes">
                        Bonjour à tous. Je suis Michael Borde, développeur passionné chez Arpinum. Je remercie
                        l'organisation pour ce bel évènement et je tenais à vous dire que je suis très heureux d'être
                        parmis vous. Je vais vous parler de mon hobby du moment : les tests automatisés en Bash.
                    </aside>
                </section>
                <!--<section>--><!--<h1>#!</h1>-->

                <!--<h3>Tests automatisés en Bash</h3>-->

                <!--<p>--><!--<small><a href="https://twitter.com/michael_borde">Michael Borde</a> / <a-->
                <!--href="http://www.arpinum.fr">www.arpinum.fr</a> / <a href="http://twitter.com/arpinum">@arpinum</a>-->
                <!--</small>--><!--</p>-->
                <!--<img width="10%" height="10%" src="images/logo-arpinum.png" alt="Arpinum"/>--><!--</section>-->

                <section>
                    <h2>Le contexte</h2>

                    <aside class="notes">
                        Je travaille sur un plateau de développement et je suis en charge, avec mon équipe, d'améliorer
                        le quotidien de tous nos fabricants.
                    </aside>
                </section>

                <section>
                    <h2>Ces 28 derniers jours</h2>

                    <div>
                        <img width="10%" height="10%" src="images/28-jours-plus-tard.jpg" alt="28 jours plus tard"/>
                    </div>

                    <ul>
                        <li>109 entrepôts</li>
                        <li>1812 commits</li>
                        <li>48 auteurs actifs</li>
                    </ul>

                    <aside class="notes">
                        Nous sommes suffisamment nombreux pour que ce travail soit aussi intéressant que compliqué.
                    </aside>
                </section>

                <section>
                    <p>Et si nous automatisions les opérations répétitives et sensibles ?</p>

                    <aside class="notes">
                        Tout a commencé lorsque nous avons décidé d'automatiser certaines opérations répétitives et
                        sensibles du quotidien.
                    </aside>
                </section>

                <section>
                    <h2>Un outil simple : Bash</h2>
                    <img width="60%" height="60%" src="images/cle-a-molette.jpg" alt="Clé à molette"/>
                    <aside class="notes">
                        En faisant le tour de nos postes de développements et des différents serveurs, le plus simple
                        était d'utiliser Bash.
                    </aside>
                </section>

                <section>
                    <h2>3 fois rien finalement</h2>
                    <ul>
                        <li>Cloner des entrepôts</li>
                        <li>Mettre à jour des sources</li>
                    </ul>
                    <aside class="notes">
                        3 fois rien finalement : cloner ou mettre à jour en masse des entrepôts Git.
                    </aside>
                </section>

                <section>
                    <h2>Mais avec un peu d'imagination</h2>
                    <ul>
                        <li>Créer/supprimer des branches</li>
                        <li>Créer/supprimer des jobs Jenkins</li>
                        <li>Lister les entrepôts à fusionner</li>
                        <li>Réaliser la livraison des projets</li>
                        <li>etc.</li>
                    </ul>
                    <p>18 vaillants scripts</p>
                    <aside class="notes">
                        Mais bien vite nous avons imaginé de nombreux cas d'utilisations : créer des branches ou jobs
                        Jenkins en masse, livrer les projets de manière automatique, etc.
                    </aside>
                </section>

                <section>
                    <h2>Et il y en a pour tout le monde</h2>
                    <img width="60%" height="60%" src="images/equipe-developpement.jpg" alt="Equipe développement"/>

                    <p>Développeurs, administrateurs, livreurs, etc.</p>
                    <aside class="notes">
                        Ils concernent un peu tout le monde : développeurs, administrateurs, etc.
                    </aside>
                </section>

                <section>
                    <h2>Dans des contextes multiples</h2>
                    <img width="20%" height="20%" src="images/logo-cygwin.png" alt="Logo Cygwin"/> <img width="20%"
                                                                                                        height="20%"
                                                                                                        src="images/logo-jenkins.png"
                                                                                                        alt="Logo Jenkins"/>
                    <img width="20%" height="20%" src="images/logo-linux.png" alt="Logo Linux"/>

                    <p class="fragment">avec un mode de tests manuels, mais chut!</p>

                    <aside class="notes">
                        Ils sont utilisables sur un poste de développement Windows, un serveur Linux ou via un job
                        Jenkins. Il y a même un mode test pour vérifier qu'on ne va pas déclencher l'enfer en situation
                        réelle.
                    </aside>
                </section>

                <section>
                    <h2>Les conseils de Google</h2>
                    <blockquote>
                        If you are writing a script that is more than 100 lines long, you should probably be writing it
                        in Python instead.
                    </blockquote>

                    <aside class="notes">
                        Nosu appliquons les préconisations Bash des équipes de Google, sauf une peut-être : "si vous
                        écrivez un script de plus de 100 lignes, vous devriez surement l'écrire en Python."
                    </aside>
                </section>

                <section>
                    <p>En python!</p>
                    <figure>
                        <img width="60%" height="60%" src="images/dawson-triste.jpg" alt="Dawson triste"/>
                        <figcaption>
                            <small>© Toute la production de Dawson's Creek</small>
                        </figcaption>
                    </figure>
                    <aside class="notes">
                        En python! Il est malheureusement Dawson, il n'a pas envie de faire du python.
                    </aside>
                </section>

                <section>
                    <p>Eh oui, scripter en Bash c'est un peu...</p>
                    <img width="20%" height="20%" src="images/dé.jpg" alt="Dé"/> <img width="20%" height="20%"
                                                                                      src="images/stackoverflow.png"
                                                                                      alt="Stackoverflow"/> <img
                        width="20%" height="20%" src="images/necronomicon.jpg" alt="Necronomicon"/>
                    <aside class="notes">
                        Mais c'est compréhensible. Quand je regarde des exemples de code sur le net je me dis que
                        scripter en Bash c'est un peu de chance et beaucoup de Stackoverflow. Heureusement dans les
                        situations désespérées il reste le Nécronomicon.
                    </aside>
                </section>

                <section>
                    <h2>Et pourtant 4796 lignes de Bash ! </h2>
                    <aside class="notes">
                        Et pourtant nous avons accumulé près de 5000 lignes de Bash.
                    </aside>
                </section>

                <section>
                    <img width="60%" height="60%" src="images/panneau-stop.jpg" alt="Panneau stop"/>

                    <aside class="notes">
                        Bash n'est pas le problème de fond!
                    </aside>
                </section>

                <section>
                    <h2>Il faut tacler la complexité</h2>

                    <aside class="notes">
                        Notre ennemi est la complexité.
                    </aside>
                </section>

                <section>
                    <p>Et si Bash était un langage de programmation ?</p>

                    <aside class="notes">
                        Et si Bash n'était pas un langage de script mais un langage de programmation comme les autres?
                    </aside>
                </section>

                <section>
                    <h2>Les outils habituels</h2>
                    <img width="20%" height="20%" src="images/livre-tdd-by-example.jpeg" alt="TDD By Example"/> <img
                        width="20%" height="20%" src="images/livre-xp-explained.jpg" alt="XP Explained"/> <img
                        width="20%" height="20%" src="images/livre-clean-code.jpg" alt="Clean Code"/>
                    <aside class="notes">
                        Alors je dégainerais TDD, XP et Clean Code.
                    </aside>
                </section>

                <section>
                    <h2>Clean Code, concrètement?</h2>
                    <aside class="notes">
                        Même en Bash il est possible de respecter le principe de responsabilité unique ou d'avoir du
                        code sans duplication et qui exprime l'intention.
                    </aside>
                </section>

                <section>
                    <h2>Un équivalent à JUnit?</h2>
                    <img width="30%" height="30%" src="images/junit.jpg" alt="JUnit"/>
                    <aside class="notes">
                        Par contre, existe t-il un équivalent à JUnit pour Bash?
                    </aside>
                </section>

                <section>
                    <p>Bof...</p>
                    <aside class="notes">
                        Bof... et je ne me satisfais pas d'un bof.
                    </aside>
                </section>

                <section>
                    <p>Je vais créer mon api de tests automatisés en Bash...</p>
                    <img width="60%" height="60%" src="images/serious-cat.jpg" alt="Serious cat"/>
                    <aside class="notes">
                        Alors j'ai décidé de créer ma propre api de tests automatisés en Bash!
                    </aside>
                </section>

                <section>
                    <h2>Les objectifs de l'api</h2>
                    <ul>
                        <li>Favoriser TDD</li>
                        <li>Ressembler à xUnit</li>
                        <li>Compatible avec l'IC</li>
                        <li>Respecter la notion de tests unitaires</li>
                        <li>En français</li>
                    </ul>
                    <aside class="notes">
                        L'objectif numéro 1 de l'API était de favoriser TDD. Mais je souhaitais aussi quelle ressemble à
                        xUnit, soit compatible avec Jenkins et respecte la notion de tests unitaires. Si en plus elle
                        pouvait être en français comme le reste de mon code, ça serait parfait.
                    </aside>
                </section>

                <section>
                    <h2>Make them <strong>first</strong></h2>
                    <ul>
                        <li><strong>F</strong>ast</li>
                        <li><strong>I</strong>solated <span class="exclamation">!</span></li>
                        <li><strong>R</strong>epeatable <span class="exclamation">!</span></li>
                        <li><strong>S</strong>elf-verifying <span class="exclamation">!</span></li>
                        <li><strong>T</strong>imely</li>
                    </ul>
                    <aside class="notes">
                        En m'appuyant sur la définiton FIRST de test unitaire, je voulais me concentrer sur les 3 points
                        du milieu : isolé, répétable, auto-vérifiant. Isolé, est une gageure par exemple. En Bash nous
                        pouvons facilement modifier des variables globales, créer ou détruire des arborescences.
                    </aside>
                </section>

                <section>
                    <h2>Et donc?</h2>
                    <aside class="notes">
                        Et donc voici quelques exemples de l'API. Ils sont un peu édulcorés pour faciliter la
                        compréhension.
                    </aside>
                </section>

                <section>
                    <h2>L'exécuteur de test</h2>
                </section>

                <section>
                    <h2>Exécuter tous les fichiers de test</h2>
                    <pre><code data-trim class="bash">
function executeur_executeLesFichiersDeTestDansLeRepertoire() {
    local repertoire=$1
    _initialiseLExecutionDesTests
    _executeTousFichiersDeTest "${repertoire}" "*Test.sh"
    _afficheLeResultatDesTests
    _retourneUnCodeEnFonctionDuResultatDesTests
}
                    </code></pre>
                    <aside class="notes">
                        L'exécuteur exécute tous les fichiers de tests qui respectent un certain pattern pour un
                        répertoire donné. Il affiche le résultat global des tests et retourne un code en fonction de
                        l'exécution.
                    </aside>
                </section>

                <section>
                    <h2>Exécuter un fichier de test</h2>
                    <pre><code data-trim class="bash">
function _executeLeFichierDeTest() {
    local fichier=$1
    source "${fichier}"
    local fonctions=($(_fonctionsPubliquesDansLeFichier "${fichier}"))
    _executeFonctionSiPresente "avantTousLesTests" "${fonctions[@]}"
    _executeTousLesTests "${fonctions[@]}"
    _executeFonctionSiPresente "apresTousLesTests" "${fonctions[@]}"
}
                    </code></pre>
                    <aside class="notes">
                        Pour un fichier de test, il récupère les fonctions publiques qui par convention seront les
                        fonctions de test. Il exécute tous les tests entre les setups et teardowns globaux si présents.
                    </aside>
                </section>

                <section>
                    <h2>Exécuter une fonction de test</h2>

                    <pre><code data-trim class="bash">
function _executeLaFonctionAuMilieuDuSetupEtTeardown() {
    local fonction=$1
    shift 1
    _executeFonctionSiPresente "avantChaqueTest" "$@" \
    && ${fonction} \
    && _executeFonctionSiPresente "apresChaqueTest" "$@"
    _analyseLExecutionDuTest "${fonction}" $?
}
                    </code></pre>
                    <aside class="notes">
                        Pour une fonction de test, il l'exécute entre le setup et teardown si présents et analyse le
                        code retour de tout ceci.
                    </aside>
                </section>

                <section>
                    <h2>Quelques affirmations</h2>
                    <aside class="notes">
                        Une API de test automatisés ne serait rien sans ses affirmations.
                    </aside>
                </section>

                <section>
                    <h2>Affirmer l'égalité</h2>
                    <pre><code data-trim class="bash">
function affirmation_affirmeEgalite() {
    local attendu=$1
    local obtenu=$2
    if [[ "${attendu}" != "${obtenu}" ]]; then
      _affirmationEnErreur "Obtenu : <${obtenu}>, attendu : <${attendu}>."
    fi
}
                    </code></pre>
                    <aside class="notes">
                        Voici une simple affirmation pour l'égalité.
                    </aside>
                </section>

                <section>
                    <h2>Affirmer le succés</h2>
                    <pre><code data-trim class="bash">
function affirmation_affirmeSucces() {
    ( $@ )
    if (( $? != 0 )); then
        _affirmationEnErreur "La commande a échoué au lieu de réussir."
    fi
}
                    </code></pre>
                    <aside class="notes">
                        Une autre pour affirmer le succès d'une commande.
                    </aside>
                </section>

                <section>
                    <h2>Quelques exemples</h2>
                    <aside class="notes">
                        Quelques exemples de tests.
                    </aside>
                </section>

                <section>
                    <h2>Un test unitaire</h2>
                        <pre><code data-trim class="bash">
function recupereBienLaVersionDunPom() {
    local pom="${_ressources}/pom_1.0-SNAPSHOT.xml"

    local version=$(maven_recupereLaVersionDuPom "${pom}")

    affirmation_affirmeEgalite "1.0-SNAPSHOT" "${version}"
}
                        </code></pre>
                </section>

                <section>
                    <h2>Un test d'intégration</h2>
                        <pre><code data-trim class="bash">
function ilEstPossibleDeChangerLaBrancheDUnEntrepot() {
    entrepot_cloneLaBrancheDeLEntrepot "integration" "module-a"

    source "${REPERTOIRE_SCRIPT}/checkout.sh" "master" "module-a"

    local branche="$(_recupereLaBrancheCouranteDeLEntrepot "module-a")"
    affirmation_affirmeEgalite "master" "${branche}"
}
                        </code></pre>
                </section>

                <section>
                    <figure>
                        <img width="100%" height="100%" src="images/resultat-tests.png" alt="Résultat tests"/>
                        <figcaption>
                            Exemple de sortie console
                        </figcaption>
                    </figure>
                </section>

                <section>
                    <h2>Reprenons les statistiques</h2>

                    <p>Lignes de code Bash :</p>
                    <ul>
                        <li><strong>Total</strong> : 4796 (100%)</li>
                        <li><strong>Production</strong> : 2797 (58%)</li>
                        <li><strong>Tests</strong> : 1671 (35%)</li>
                        <li><strong>API de tests</strong> : 328 (7%)</li>
                    </ul>
                </section>

                <section>
                    <h2>Et pour le fun</h2>

                    <p>Nombre de tests (temps) :</p>
                    <ul>
                        <li><strong>Tests unitaires</strong> : 91 (13 s)</li>
                        <li><strong>Tests d'intégration</strong> : 109 (10 min)</li>
                    </ul>
                </section>

                <section>
                    <h2>Fin</h2>

                    <p>Pour les curieux :</p>

                    <p><a href="http://github.com/arpinum/shebang_unit" title="shebang_unit">http://github.com/arpinum/shebang_unit</a>
                    </p>
                </section>
            </div>

        </div>

        <script src="reveal.js/lib/js/head.min.js"></script>
        <script src="reveal.js/js/reveal.min.js"></script>

        <script>

            Reveal.initialize({
                controls: false,
                progress: true,
                history: true,
                center: true,
                mouseWheel: true,

                theme: Reveal.getQueryHash().theme || 'beige',
                transition: Reveal.getQueryHash().transition || 'none',

                dependencies: [
                    { src: 'reveal.js/lib/js/classList.js', condition: function () {
                        return !document.body.classList;
                    } },
                    { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function () {
                        hljs.initHighlightingOnLoad();
                    } },
                    { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function () {
                        return !!document.body.classList;
                    } }
                ]
            });
        </script>

    </body>
</html>
